The implementation of this project is inspired by past problem sets - especially CS50 Finance, Movies, and Homepage - in which I had the opportunity to familiarize myself with some basics of HTML, CSS, SQL, and Flask. I use the Flask MVC or Model-View-Controller framework to organize my codes and design the website. Here is the overview of what’s contained in each:

CONTROLLER:
- `application.py`: this is where I (1) configure the application and (2) instruct the program to perform specific functions in response to users’ requests.
The first part is configuration - where I configure Flask, make sure responses are not cached, store Flask-sessions on local filesystem, and configure CS50’s SQL to use emolog.db - an SQLite database that contains users’ information.
The second part contains different routes as users navigate through the web. For each route, a function is specified to return different results based on users’ requests. Upon visiting a route, users can give two types of request: GET and POST. When the request method is GET, users simply want the website to be displayed. In this case, the requested display usually involves a form, an instruction, or users’ past information input. When the request method is POST, users want the website to process the information they have put in. In this case, the POST method is implemented when users register information or submit their journal entries/relationship tracker form. Specifically:
- `index()` is called when users visit the homepage. This function simply renders template `index.html`
- `register()` is called when users press the ‘Join EMoG’ button. This function returns a form when users want to get the form. Once the users submit their information, the function checks if users’ input is valid and query the database to see if the username already exists. Once verified, the function inserts user data into a table called `users` in `emolog.db`. Users’ passwords are hashed before entering the database to protect users’ privacy.
- `login()` renders the `login.html` template which gives users a login form upon request. Once users submit their information, the function checks if the typed in password matches the “hash” value in the `users` database. It `remembers` users’ ID and stores it inside `session`, thereby allowing users to stay logged in. Meanwhile, `logout` clears users’ sessions and redirects them to the homepage. All routes that allow users to journal, track time spent on relationships, and see their own data are decorated with `@login_required` - a function defined in `helpers.py`
- `invitation()` is called when users visit the route `/invitation`. It simply renders the template `invitation.html` which prompts users to choose to either journal or submit a relationship form
- `journal()` is called when users visit `/journal`. It displays the form `journal.html` when users want to first see the form and enter their input. Upon submitting, the function takes users’ input and inserts those inputs into another table called `entries` in `emolog.db`.
- `history()` is called when users visit `/history` upon clicking the “Entry” tab. The function queries users’ journal input and saves it into a dictionary called `histories`, then renders the template `history.html` and passes the dictionary into the template by the same name.
- `relationship()` is called when users visit `/relationship`. It displays a form as requested. Upon users’ submission, it checks for validity, inserts new data into a table called `tracker` in `emolog.db`, then redirects users to `/invitation`.
- `tracker()` is called when users visit `/tracker` upon clicking the tab “Tracker”. The function selects the constantly updated data from table `tracker` and stores them into 3 variable `pies`, `bar`, and `tracks`. `pies` (which later is used for the pie chart) is a dictionary storing total hours by relationship categories. `bar` (which later is used for the column chart) is used to store total hours by people the users hang out with (limit to 10 people given authors’ prediction that users are interested in knowing at most top 10 people they spend the most time with). `tracks` stores all users’ input, which is later displayed in a datatable. This function renders the template `tracker.html` and passes all three variables as parameters into this template.
- `helpers.py` implements the `@login_required` decorator, which prompts the users to log in again should their sessions are cleared. It also implements CS50’s signature `apology()` function, which returns a funny meme with an error message signaling users’ invalid input.
- `notes.sql` is more for myself. I find it easier to scrutinize and detect possible typos/errors in my SQL commands using the `.sql` file as opposed to typing them directly into the terminal

# VIEW:

This includes the folders `templates` (contains all HTML files) and `static` (contains one CSS file). The folder `templates` contains a `layout.html` which contains all the common elements that will appear as users visit different routes (I add one if-else specification to differentiate appearance of the navbar and some buttons before and after the users log in). I then use `Jinja` to extend this layout to all other HTML files. `Jinja` is also used to loop through database and pass data into tables in `history.html` and `tracker.html`
Overall the design is entirely inspired by Brian Design and his tutorial (reference link: https://www.youtube.com/watch?v=FazgJVnrVuI) and managed to implement different elements of design using CSS and Javascript, including highlighting the navbar tabs, specifying CSS grid and flexbox, and adding gradient color effects to make the design more interesting and visually pleasant.
- As for data analytics, I use Javascript Google Flask Charts to display my charts which were constantly updated as users submit more information. I use the package `json` to parse data from database `tracker` and convert them into java objects, then I create a two-dimensional array convert the array to data table, enabling Google Flask Charts to process the data into specified charts.
- As for the search engine, I also use Java to implement the search engine and CSS to create a search bar. By converting users’ search input to uppercase letters, the engine becomes case-insensitive. By looping through the data cells `td` for each row `tr` until it reaches the last row ( < row’s length), I am able to display rows whose data cell matches with users’ input.

# MODEL:
- `emolog.db`: application’s database, containing aforementioned tables `users`, `tracker`, and `entries`
